     2   dorothyr #
     2   dorothyr # TCL Library for TkCVS
     2   dorothyr #
     2   dorothyr 
     2   dorothyr #
     2   dorothyr # $Id: cvs.tcl,v 1.131 2005/07/15 21:30:14 dorothyr Exp $
     2   dorothyr # 
     2   dorothyr # Contains procedures used in interaction with CVS.
     2   dorothyr #
     2   dorothyr 
     2   dorothyr proc cvs_notincvs {} {
     2   dorothyr   cvsfail "This directory is not in CVS." .workdir
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_incvs {} {
     2   dorothyr   cvsfail "You can\'t do that here because this directory is already in CVS." .workdir
     2   dorothyr }
     2   dorothyr 
     2   dorothyr #
     2   dorothyr #  Create a temporary directory
     2   dorothyr #  cd to that directory
     2   dorothyr #  run the CVS command in that directory
     2   dorothyr #
     2   dorothyr #  returns: the current wd (ERROR) or the sandbox directory (OK)
     2   dorothyr #
     2   dorothyr proc cvs_sandbox_runcmd {cmd output_var} {
     2   dorothyr   global cvscfg
     2   dorothyr   global cwd
     2   dorothyr 
     2   dorothyr   upvar $output_var view_this
     2   dorothyr 
     2   dorothyr   # Big note: the temp directory fed to a remote servers's command line
     2   dorothyr   # needs to be seen by the server.  It can't cd to an absolute path.
     2   dorothyr   # In addition it's fussy about where you are when you do a checkout -d.
     2   dorothyr   # Best avoid that altogether.
     2   dorothyr   gen_log:log T "ENTER ($cmd $output_var)"
     2   dorothyr   set pid [pid]
     2   dorothyr   
     2   dorothyr   if {! [file isdirectory $cvscfg(tmpdir)]} {
     2   dorothyr     gen_log:log F "MKDIR $cvscfg(tmpdir)"
     2   dorothyr     file mkdir $cvscfg(tmpdir)
     2   dorothyr   }
     2   dorothyr   cd $cvscfg(tmpdir)
     2   dorothyr   gen_log:log F "CD [pwd]"
     2   dorothyr   if {! [file isdirectory cvstmpdir.$pid]} {
     2   dorothyr     gen_log:log F "MKDIR cvstmpdir.$pid"
     2   dorothyr     file mkdir cvstmpdir.$pid
     2   dorothyr   }
     2   dorothyr   cd cvstmpdir.$pid
     2   dorothyr   gen_log:log F "CD [pwd]"
     2   dorothyr 
     2   dorothyr   gen_log:log C "$cmd"
     2   dorothyr   set ret [catch {eval "exec $cmd"} view_this]
     2   dorothyr   gen_log:log T "RETURN $cvscfg(tmpdir)/cvstmpdir.$pid"
     2   dorothyr   return $cvscfg(tmpdir)/cvstmpdir.$pid
     2   dorothyr }
     2   dorothyr 
     2   dorothyr #
     2   dorothyr #  cvs_sandbox_filetags
     2   dorothyr #   assume that the sandbox contains the checked out files
     2   dorothyr #   return a list of all the tags in the files
     2   dorothyr #
     2   dorothyr proc cvs_sandbox_filetags {mcode filenames} {
     2   dorothyr   global cvscfg
     2   dorothyr   global cvs
     2   dorothyr 
     2   dorothyr   set pid [pid]
     2   dorothyr   set cwd [pwd]
     2   dorothyr   gen_log:log T "ENTER ($mcode $filenames)"
     2   dorothyr   
     2   dorothyr   cd [file join $cvscfg(tmpdir) cvstmpdir.$pid $mcode]
     2   dorothyr   set commandline "$cvs log $filenames"
     2   dorothyr   gen_log:log C "$commandline"
     2   dorothyr   set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr   if {$ret} {
     2   dorothyr     cd $cwd
     2   dorothyr     cvsfail $view_this .merge
     2   dorothyr     gen_log:log T "LEAVE ERROR"
     2   dorothyr     return $keepers
     2   dorothyr   }
     2   dorothyr   set view_lines [split $view_this "\n"]
     2   dorothyr   foreach line $view_lines {
     2   dorothyr     if {[string index $line 0] == "\t" } {
     2   dorothyr       regsub -all {[\t ]*} $line "" tag
     2   dorothyr       append keepers "$tag "
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   cd $cwd
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr   return $keepers
     2   dorothyr }
     2   dorothyr 
     8   dorothyr proc cvs_workdir_status {} {
     8   dorothyr   global cvscfg
     8   dorothyr   global cvs
     8   dorothyr   global Filelist
     8   dorothyr 
     8   dorothyr   gen_log:log T "ENTER"
     8   dorothyr 
     8   dorothyr   set cmd(cvs_status) [exec::new "$cvs -n -q status -l"]
     8   dorothyr   set status_lines [split [$cmd(cvs_status)\::output] "\n"]
     8   dorothyr   if {$cvscfg(econtrol)} {
     8   dorothyr     set cmd(cvs_editors) [exec::new "$cvs -n -q editors -l"]
     8   dorothyr     set editors_lines [split [$cmd(cvs_editors)\::output] "\n"]
     8   dorothyr   }
     8   dorothyr   if {[info exists cmd(cvs_status)]} {
     8   dorothyr     #gen_log:log F "processing files that CVS knows about"
     8   dorothyr     # gets cvs status in current directory only, pulling out lines that include
     8   dorothyr     # Status: or Sticky Tag:, putting each file's info (name, status, and tag)
     8   dorothyr     # into an array.
     8   dorothyr 
     8   dorothyr     unset cmd(cvs_status)
     8   dorothyr     foreach logline $status_lines {
     8   dorothyr       if {[string match "File:*" $logline]} {
     8   dorothyr         regsub -all {\t+} $logline "\t" logline
     8   dorothyr         set line [split [string trim $logline] "\t"]
     8   dorothyr         gen_log:log D "$line"
     8   dorothyr         # Should be able to do these regsubs in one expression
     8   dorothyr         regsub {File: } [lindex $line 0] "" filename
     8   dorothyr         regsub {\s*$} $filename "" filename
     8   dorothyr         if {[string match "no file *" $filename]} {
     8   dorothyr           regsub {^no file } $filename "" filename
     8   dorothyr         }
     8   dorothyr         regsub {Status: } [lindex $line 1] "" status
     8   dorothyr         set Filelist($filename:status) $status
     8   dorothyr         # Don't set editors to null because we'll use its presence
     8   dorothyr         # or absence to see if we need to re-read the repository when
     8   dorothyr         # we ask to map the editors column
     8   dorothyr         #set Filelist($filename:editors) ""
     8   dorothyr       } elseif {[string match "*Working revision:*" $logline]} {
     8   dorothyr         regsub -all {\t+} $logline "\t" logline
     8   dorothyr         set line [split [string trim $logline] "\t"]
     8   dorothyr         gen_log:log D "$line"
     8   dorothyr         set revision [lindex $line 1]
     8   dorothyr         regsub {New .*} $revision "New" revision
     8   dorothyr         set date [lindex $line 2]
     8   dorothyr         # The date field is not supplied to remote clients.
     8   dorothyr         if {$date == "" || [string match "New *" $date ] || \
     8   dorothyr             [string match "Result *" $date]} {
     8   dorothyr           ; # Leave as is
     8   dorothyr         } else {
     8   dorothyr           set juliandate [clock scan $date -gmt yes]
     8   dorothyr           set date [clock format $juliandate -format $cvscfg(dateformat)]
     8   dorothyr           set Filelist($filename:date) $date
     8   dorothyr         }
     8   dorothyr         set Filelist($filename:wrev) $revision
     8   dorothyr         set Filelist($filename:status) $status
     8   dorothyr       } elseif {[string match "*Sticky Tag:*" $logline]} {
     8   dorothyr         regsub -all {\t+} $logline "\t" logline
     8   dorothyr         set line [split [string trim $logline] "\t"]
     8   dorothyr         gen_log:log D "$line"
     8   dorothyr         set tagline [lindex $line 1]
     8   dorothyr         set t0 [lindex $tagline 0]
     8   dorothyr         set t1 [lrange $tagline 1 end]
     8   dorothyr         set stickytag ""
     8   dorothyr         if { $t0 == "(none)" } {
     8   dorothyr           set stickytag " on trunk"
     8   dorothyr         } elseif {[string match "(branch:*" $t1 ]} {
     8   dorothyr           regsub {\(branch: (.*)\)} $t1 {\1} t1
     8   dorothyr           set stickytag " on $t0  branch"
     8   dorothyr         } elseif {[string match "(revision:*" $t1 ]} {
     8   dorothyr           set stickytag " $t0"
     8   dorothyr         }
     8   dorothyr         set Filelist($filename:stickytag) "$revision $stickytag"
     8   dorothyr       } elseif {[string match "*Sticky Options:*" $logline]} {
     8   dorothyr         regsub -all {\t+} $logline "\t" logline
     8   dorothyr         set line [split [string trim $logline] "\t"]
     8   dorothyr         gen_log:log D "$line"
     8   dorothyr         set option [lindex $line 1]
     8   dorothyr         set Filelist($filename:option) $option
     8   dorothyr       }
     8   dorothyr     }
     8   dorothyr   }
     8   dorothyr 
     8   dorothyr   if {[info exists cmd(cvs_editors)]} {
     8   dorothyr     set filename {}
     8   dorothyr     unset cmd(cvs_editors)
     8   dorothyr     foreach logline $editors_lines {
     8   dorothyr       set line [split $logline "\t"]
     8   dorothyr       gen_log:log D "$line"
     8   dorothyr       set ell [llength $line]
     8   dorothyr       # ? files will show up in cvs editors output under certain conditions
     8   dorothyr       if {$ell < 5} {
     8   dorothyr         continue
     8   dorothyr       }
     8   dorothyr       #if there is no filename, then this is a continuation line
     8   dorothyr       set f [lindex $line 0]
     8   dorothyr       if {$f == {}} {
     8   dorothyr         append editors ",[lindex $line 1]"
     8   dorothyr       } else {
     8   dorothyr         if {$filename != {}} {
     8   dorothyr           set Filelist($filename:editors) $editors
     8   dorothyr         }
     8   dorothyr         set filename $f
     8   dorothyr         set editors [lindex $line 1]
     8   dorothyr       }
     8   dorothyr       gen_log:log D " $filename   $editors"
     8   dorothyr     }
     8   dorothyr     if {$filename != {}} {
     8   dorothyr       set Filelist($filename:editors) $editors
     8   dorothyr     }
     8   dorothyr   }
     8   dorothyr   gen_log:log T "LEAVE"
     8   dorothyr }
     8   dorothyr 
     2   dorothyr proc cvs_remove {args} {
     2   dorothyr #
     2   dorothyr # This deletes a file from the directory and the repository,
     2   dorothyr # asking for confirmation first.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr 
     2   dorothyr   set success 1
     2   dorothyr   set faillist ""
     2   dorothyr   foreach file $filelist {
     2   dorothyr     file delete -force -- $file
     2   dorothyr     gen_log:log F "DELETE $file"
     2   dorothyr     if {[file exists $file]} {
     2   dorothyr       set success 0
     2   dorothyr       append faillist $file
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {$success == 0} {
     2   dorothyr     cvsfail "Remove $file failed" .workdir
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set cmd [exec::new "$cvs remove $filelist"]
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     $cmd\::wait
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_remove_dir {args} {
     2   dorothyr # This removes files recursively.
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     cvsfail "Please select a directory!" .workdir
     2   dorothyr     return 
     2   dorothyr   } else {
     2   dorothyr     set mess "This will remove the contents of these directories:\n\n"
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append mess "   $file\n"
     2   dorothyr     }  
     2   dorothyr   }
     2   dorothyr   
     2   dorothyr   set v [viewer::new "CVS Remove directory"]
     2   dorothyr 
     2   dorothyr   set awd [pwd]
     2   dorothyr   foreach file $filelist {
     2   dorothyr     if {[file isdirectory $file]} {
     2   dorothyr       set awd [pwd]
     2   dorothyr       cd $file
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr       rem_subdirs $v
     2   dorothyr       cd $awd
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr 
     2   dorothyr       set commandline "$cvs remove \"$file\""
     2   dorothyr       #gen_log:log C "$commandline"
     2   dorothyr       $v\::do "$commandline" 1 status_colortags
     2   dorothyr       $v\::wait
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_edit {args} {
     2   dorothyr #
     2   dorothyr # This sets the edit flag for a file
     2   dorothyr # asking for confirmation first.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr 
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   foreach file [join $args] {
     2   dorothyr     regsub -all {\$} $file {\$} file
     2   dorothyr     set commandline "$cvs edit \"$file\""
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr     if {$ret != 0} {
     2   dorothyr       view_output::new "CVS Edit" $view_this
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_unedit {args} {
     2   dorothyr #
     2   dorothyr # This resets the edit flag for a file.
     2   dorothyr # Needs stdin as there is sometimes a dialog if file is modified
     2   dorothyr # (defaults to no)
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr 
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   foreach file [join $args] {
     2   dorothyr     # Unedit may hang asking for confirmation if file is not up-to-date
     2   dorothyr     regsub -all {\$} $file {\$} file
     2   dorothyr     set commandline "cvs -n update \"$file\""
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     catch {eval "exec $commandline"} view_this
     2   dorothyr     # Its OK if its locally added
     2   dorothyr     if {([llength $view_this] > 0) && ![string match "A*" $view_this] } {
     2   dorothyr       gen_log:log D "$view_this"
     2   dorothyr       cvsfail "File $file is not up-to-date" .workdir
     2   dorothyr       gen_log:log T "LEAVE -- cvs unedit failed"
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr 
     2   dorothyr     set commandline "$cvs unedit \"$file\""
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr     if {$ret != 0} {
     2   dorothyr       view_output::new "CVS Edit" $view_this
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_history {allflag mcode} {
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   set all ""
     2   dorothyr   gen_log:log T "ENTER ($allflag $mcode)"
     2   dorothyr   if {$allflag == "all"} {
     2   dorothyr     set all "-a"
     2   dorothyr   }
     2   dorothyr   if {$mcode == ""} {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) history $all"
     2   dorothyr   } else {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) history $all -n $mcode"
     2   dorothyr   }
     2   dorothyr   # FIXME: If $all, it would be nice to process the output
     2   dorothyr   set v [viewer::new "CVS History"]
     2   dorothyr   $v\::do "$commandline"
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_add {binflag args} {
     2   dorothyr #
     2   dorothyr # This adds a file to the repository.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($binflag $args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     set mess "This will add all new files"
     2   dorothyr   } else {
     2   dorothyr     set mess "This will add these files:\n\n"
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append mess "   $file\n"
     2   dorothyr     }  
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     append filelist [glob -nocomplain $cvscfg(aster) .??*]
     2   dorothyr   }
     2   dorothyr   set cmd [exec::new "$cvs add $binflag $filelist"]
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     $cmd\::wait
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_add_dir {binflag args} {
     2   dorothyr # This starts adding recursively at the directory level
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($binflag $args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     cvsfail "Please select a directory!" .workdir
     2   dorothyr     return 1
     2   dorothyr   } else {
     2   dorothyr     set mess "This will recursively add these directories:\n\n"
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append mess "   $file\n"
     2   dorothyr     }  
     2   dorothyr   }
     2   dorothyr   
     2   dorothyr   set v [viewer::new "CVS Add directory"]
     2   dorothyr 
     2   dorothyr   set awd [pwd]
     2   dorothyr   foreach file $filelist {
     2   dorothyr     if {[file isdirectory $file]} {
     2   dorothyr       set commandline "$cvs add \"$file\""
     2   dorothyr       #gen_log:log C "$commandline"
     2   dorothyr       $v\::do "$commandline"
     2   dorothyr       $v\::wait
     2   dorothyr 
     2   dorothyr       cd $file
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr       add_subdirs $binflag $v
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   cd $awd
     2   dorothyr   gen_log:log F "[pwd]"
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc add_subdirs {binflag v} {
     2   dorothyr   global cvs
     2   dorothyr   global cvsglb
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($binflag $v)"
     2   dorothyr   set plainfiles {}
     2   dorothyr   foreach child  [glob -nocomplain $cvscfg(aster) .??*] {
     2   dorothyr     if [file isdirectory $child] {
     2   dorothyr       if {[regexp -nocase {^CVS$} [file tail $child]]} {
     2   dorothyr         gen_log:log D "Skipping $child"
     2   dorothyr         continue
     2   dorothyr       }
     2   dorothyr       set commandline "$cvs add \"$child\""
     2   dorothyr       #gen_log:log C "$commandline"
     2   dorothyr       $v\::do "$commandline"
     2   dorothyr       $v\::wait
     2   dorothyr       set awd [pwd]
     2   dorothyr       cd $child
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr       add_subdirs $binflag $v
     2   dorothyr       cd $awd
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr     } else {
     2   dorothyr       lappend plainfiles $child
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {[llength $plainfiles] > 0} {
     2   dorothyr     # LJZ: get local ignore file filter list
     2   dorothyr     set ignore_file_filter $cvsglb(default_ignore_filter)
     2   dorothyr     if { [ file exists ".cvsignore" ] } {
     2   dorothyr       set fileId [ open ".cvsignore" "r" ]
     2   dorothyr       while { [ eof $fileId ] == 0 } {
     2   dorothyr         gets $fileId line
     2   dorothyr         append ignore_file_filter " $line"
     2   dorothyr       }
     2   dorothyr       close $fileId
     2   dorothyr     }
     2   dorothyr 
     2   dorothyr     # LJZ: ignore files if requested in recursive add
     2   dorothyr     if { $ignore_file_filter != "" } {
     2   dorothyr       foreach item $ignore_file_filter {
     2   dorothyr         # for each pattern
     2   dorothyr         if { $item != "*" } {
     2   dorothyr           # if not "*"
     2   dorothyr           while { [set idx [lsearch $plainfiles $item]] != -1 } {
     2   dorothyr             # for each occurence, delete
     2   dorothyr             catch { set plainfiles [ lreplace $plainfiles $idx $idx ] }
     2   dorothyr           }
     2   dorothyr         }
     2   dorothyr       }
     2   dorothyr     }
     2   dorothyr 
     2   dorothyr     # LJZ: any files left after filtering?
     2   dorothyr     if {[llength $plainfiles] > 0} {
     2   dorothyr       set commandline "$cvs add $binflag $plainfiles"
     2   dorothyr       #gen_log:log C "$commandline"
     2   dorothyr       $v\::do "$commandline"
     2   dorothyr       $v\::wait
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc rem_subdirs { v } {
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($v)"
     2   dorothyr   set plainfiles {}
     2   dorothyr   foreach child  [glob -nocomplain $cvscfg(aster) .??*] {
     2   dorothyr     if [file isdirectory $child] {
     2   dorothyr       if {[regexp -nocase {^CVS$} [file tail $child]]} {
     2   dorothyr         gen_log:log D "Skipping $child"
     2   dorothyr         continue
     2   dorothyr       }
     2   dorothyr       set awd [pwd]
     2   dorothyr       cd $child
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr       rem_subdirs $v
     2   dorothyr       cd $awd
     2   dorothyr       gen_log:log F "CD [pwd]"
     2   dorothyr     } else {
     2   dorothyr       lappend plainfiles $child
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {[llength $plainfiles] > 0} {
     2   dorothyr     foreach file $plainfiles {
     2   dorothyr       gen_log:log F "DELETE $file"    
     2   dorothyr       file delete -force -- $file
     2   dorothyr       if {[file exists $file]} {cvsfail "Remove $file failed" .workdir}
     2   dorothyr     }
     2   dorothyr     set commandline "$cvs remove $plainfiles"
     2   dorothyr     #gen_log:log C "$commandline"
     2   dorothyr     $v\::do "$commandline"
     2   dorothyr     $v\::wait
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_fileview_update {revision filename} {
     2   dorothyr #
     2   dorothyr # This views a specific revision of a file in the repository.
     2   dorothyr # For files checked out in the current sandbox.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($filename $revision)"
     2   dorothyr   if {$revision == {}} {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) update -p \"$filename\""
     2   dorothyr     #gen_log:log C "$commandline"
     2   dorothyr     set v [viewer::new "$filename"]
     2   dorothyr     $v\::do "$commandline"
     2   dorothyr   } else {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) update -p -r $revision \"$filename\""
     2   dorothyr     #gen_log:log C "$commandline"
     2   dorothyr     set v [viewer::new "$filename Revision $revision"]
     2   dorothyr     $v\::do "$commandline"
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_fileview_checkout {revision filename} {
     2   dorothyr #
     2   dorothyr # This looks at a revision of a file from the repository.
     2   dorothyr # Called from Module Browser -> File Browse -> View
     2   dorothyr # For files not currently checked out
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($filename $revision)"
     2   dorothyr   if {$revision == {}} {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) checkout -p \"$filename\""
     2   dorothyr     #gen_log:log C "$commandline"
     2   dorothyr     set v [viewer::new "$filename"]
     2   dorothyr     $v\::do "$commandline"
     2   dorothyr   } else {
     2   dorothyr     set commandline "$cvs -d $cvscfg(cvsroot) checkout -p -r $revision \"$filename\""
     2   dorothyr     #gen_log:log C "$commandline"
     2   dorothyr     set v [viewer::new "$filename Revision $revision"]
     2   dorothyr     $v\::do "$commandline"
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_logcanvas {directory files} {
     2   dorothyr #
     2   dorothyr # This looks at the revision log of a file.  It's is called from workdir.tcl,
     2   dorothyr # when we are in a CVS-controlled directory.  Merges are enabled.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($directory $files)"
     2   dorothyr 
     2   dorothyr   if {$files == {}} {
     2   dorothyr     cvsfail "Please select one or more files!" .workdir
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   foreach file $files {
     2   dorothyr     ::logcanvas::new $directory $file "diff ok" "$cvs log \"$file\""
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_log {args} {
     2   dorothyr #
     2   dorothyr # This looks at a log from the repository.
     2   dorothyr # Called by Workdir menu Reports->"CVS log ..."
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global incvs
     2   dorothyr   global cvscfg
     2   dorothyr   global current_tagname
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set filelist [join $args]
     2   dorothyr 
     2   dorothyr   set commandline "$cvs log "
     2   dorothyr   if {$cvscfg(ldetail) == "latest"} {
     2   dorothyr     if {[llength $current_tagname] == 1} {
     2   dorothyr       # We have a branch here
     2   dorothyr       append commandline "-r$current_tagname "
     2   dorothyr     }
     2   dorothyr     append commandline "-N "
     2   dorothyr   }
     2   dorothyr   append commandline "$filelist"
     2   dorothyr 
     2   dorothyr   
     2   dorothyr   # If verbose, just output the whole thing
     2   dorothyr   if {$cvscfg(ldetail) == "verbose"} {
     2   dorothyr     set logcmd [viewer::new "CVS log ($cvscfg(ldetail))"]
     2   dorothyr     $logcmd\::do "$commandline"
     2   dorothyr     busy_done .workdir.main
     2   dorothyr     gen_log:log T "LEAVE"
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr 
     2   dorothyr   # Else we have to take out some of it
     2   dorothyr   busy_start .workdir.main
     2   dorothyr   set cooked_log ""
     2   dorothyr   set logcmd [exec::new "$commandline"]
     2   dorothyr   set log_lines [split [$logcmd\::output] "\n"]
     2   dorothyr   if {$cvscfg(ldetail) == "summary"} {
     2   dorothyr     set n -9999
     2   dorothyr     foreach logline $log_lines {
     2   dorothyr       # Beginning of a file's record
     2   dorothyr       #gen_log:log D "$logline"
     2   dorothyr       if {[string match "Working file:*" $logline]} {
     2   dorothyr         append cooked_log "$logline\n"
     2   dorothyr         # Zingggg - reset!
     2   dorothyr         set n -9999
     2   dorothyr       }
     2   dorothyr       # Beginning of a revision
     2   dorothyr       if {[string match "----------------------------" $logline]} {
     2   dorothyr         append cooked_log "$logline\n"
     2   dorothyr         set n 0
     2   dorothyr       }
     2   dorothyr       if {$n >= 1} {
     2   dorothyr         append cooked_log "$logline\n"
     2   dorothyr       }
     2   dorothyr       incr n
     2   dorothyr     }
     2   dorothyr   } elseif {$cvscfg(ldetail) == "latest"} {
     2   dorothyr     set br 0
     2   dorothyr     while {[llength $log_lines] > 0} {
     2   dorothyr       set logline [join [lrange $log_lines 0 0]]
     2   dorothyr       set log_lines [lrange $log_lines 1 end]
     2   dorothyr       #gen_log:log D "$logline"
     2   dorothyr 
     2   dorothyr       # Beginning of a file's record
     2   dorothyr       if {[string match "Working file:*" $logline]} {
     2   dorothyr         append cooked_log "$logline\n"
     2   dorothyr         while {[llength $log_lines] > 0} {
     2   dorothyr           set log_lines [lrange $log_lines 1 end]
     2   dorothyr           set logline [join [lrange $log_lines 0 0]]
     2   dorothyr           #gen_log:log D " ! $logline !"
     2   dorothyr 
     2   dorothyr           # Reason to skip
     2   dorothyr           if {[string match "*selected revisions: 0" $logline]} {
     2   dorothyr             append cooked_log "No revisions on branch\n"
     2   dorothyr             append cooked_log "======================================="
     2   dorothyr             append cooked_log "=======================================\n"
     2   dorothyr             #set br 0
     2   dorothyr             break
     2   dorothyr           }
     2   dorothyr           # Beginning of a revision
     2   dorothyr           if {[string match "----------------------------" $logline]} {
     2   dorothyr             #gen_log:log D "  !! $logline !!"
     2   dorothyr             append cooked_log "$logline\n"
     2   dorothyr             while {[llength $log_lines] > 0} {
     2   dorothyr               set log_lines [lrange $log_lines 1 end]
     2   dorothyr               set logline [join [lrange $log_lines 0 0]]
     2   dorothyr               #gen_log:log D "        $logline"
     2   dorothyr               if { [string match "========================*" $logline] ||
     2   dorothyr                   [string match "--------------*" $logline]} {
     2   dorothyr                 append cooked_log "======================================="
     2   dorothyr                 append cooked_log "=======================================\n"
     2   dorothyr                 set br 1
     2   dorothyr                 break
     2   dorothyr               } else {
     2   dorothyr                 append cooked_log "$logline\n"
     2   dorothyr               }
     2   dorothyr             }
     2   dorothyr           }
     2   dorothyr           # If we broke out of the inside loop, break out of this one too
     2   dorothyr           if {$br == 1} {set br 0; break}
     2   dorothyr         }
     2   dorothyr       }
     2   dorothyr     }
     2   dorothyr   } else {
     2   dorothyr     cvsfail "Unknown log option \"$cvscfg(ldetail)\"" .workdir
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   busy_done .workdir.main
     2   dorothyr   view_output::new "CVS Log ($cvscfg(ldetail))" $cooked_log
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_annotate {revision args} {
     2   dorothyr #
     2   dorothyr # This looks at a log from the repository.
     2   dorothyr # Called by Workdir menu Reports->"CVS log ..."
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($revision $args)"
     2   dorothyr 
     2   dorothyr   if {$revision != ""} {
     2   dorothyr     # We were given a revision
     2   dorothyr     set revflag "-r$revision"
     2   dorothyr   } else {
     2   dorothyr     set revflag ""
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     cvsfail "Annotate:\nPlease select one or more files !" .workdir
     2   dorothyr     gen_log:log T "LEAVE (Unselected files)"
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr   foreach file $filelist {
     8   dorothyr     annotate::new $revflag $file "cvs"
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     8   dorothyr proc cvs_annotate_r {revision file} {
     2   dorothyr #
     2   dorothyr # This looks at a log from the repository.
     2   dorothyr # Called by Logcanvas when not in a CVS directory
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     8   dorothyr   gen_log:log T "ENTER ($revision $file)"
     2   dorothyr 
     2   dorothyr   if {$revision != ""} {
     2   dorothyr     # We were given a revision
     2   dorothyr     set revflag "-r$revision"
     2   dorothyr   } else {
     2   dorothyr     set revflag ""
     2   dorothyr   }
     2   dorothyr 
     8   dorothyr   annotate::new $revflag $file "cvs_r"
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_commit {revision comment args} {
     2   dorothyr #
     2   dorothyr # This commits changes to the repository.
     2   dorothyr #
     2   dorothyr # The parameters work differently here -- args is a list.  The first
     2   dorothyr # element of args is a list of file names.  This is because I can't
     2   dorothyr # use eval on the parameters, because comment contains spaces.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($revision $comment $args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set filelist [lindex $args 0]
     2   dorothyr 
     2   dorothyr   # changed the message to be a little more explicit.  -sj
     2   dorothyr   set commit_output ""
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     set mess "This will commit your changes to ** ALL ** files in"
     2   dorothyr     append mess " and under this directory."
     2   dorothyr   } else {
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append commit_output "\n$file"
     2   dorothyr     }
     2   dorothyr     set mess "This will commit your changes to:$commit_output"
     2   dorothyr   }
     2   dorothyr   append mess "\n\nAre you sure?"
     2   dorothyr   set commit_output ""
     2   dorothyr 
     2   dorothyr   if {[cvsconfirm $mess .workdir] != "ok"} {
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set revflag ""
     2   dorothyr   if {$revision != ""} {
     2   dorothyr     set revflag "-r $revision"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(use_cvseditor)} {
     2   dorothyr     # Starts text editor of your choice to enter the log message.
     2   dorothyr     # This way a template in CVSROOT can be used.
     2   dorothyr     update idletasks
     2   dorothyr     set commandline \
     2   dorothyr       "$cvscfg(terminal) $cvs commit -R $revflag $filelist"
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr     if {$ret} {
     2   dorothyr       cvsfail $view_this .workdir
     2   dorothyr       gen_log:log T "LEAVE ERROR ($view_this)"
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr   } else {
     2   dorothyr     if {$comment == ""} {
     2   dorothyr       cvsfail "You must enter a comment!" .commit
     2   dorothyr       return 1
     2   dorothyr     }
     2   dorothyr     set v [viewer::new "CVS Commit"]
     2   dorothyr     regsub -all "\"" $comment "\\\"" comment
     2   dorothyr     # Lets not show stderr as it does a lot of "examining"
     2   dorothyr     $v\::do "$cvs commit -R $revflag -m \"$comment\" $filelist" 0
     2   dorothyr     $v\::wait
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_tag {tagname force branch update args} {
     2   dorothyr #
     2   dorothyr # This tags a file in a directory.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($tagname $force $branch $update $args)"
     2   dorothyr 
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$tagname == ""} {
     2   dorothyr     cvsfail "You must enter a tag name!" .workdir
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set filelist [join $args]
     2   dorothyr 
     2   dorothyr   set command "$cvs tag"
     2   dorothyr   if {$branch == "yes"} {
     2   dorothyr    append command " -b"
     2   dorothyr   }
     2   dorothyr   if {$force == "yes"} {
     2   dorothyr     append command " -F"
     2   dorothyr   }
     2   dorothyr   append command " $tagname $filelist"
     2   dorothyr   #gen_log:log C "$command"
     2   dorothyr 
     2   dorothyr   set v [viewer::new "CVS Tag"]
     2   dorothyr   $v\::do "$command"
     2   dorothyr   $v\::wait
     2   dorothyr 
     2   dorothyr   if {$update == "yes"} {
     2   dorothyr     # update so we're on the branch
     2   dorothyr     set command "$cvs update -r $tagname $filelist"
     2   dorothyr     #gen_log:log C "$command"
     2   dorothyr     $v\::do "$command" 0 status_colortags
     2   dorothyr     $v\::wait
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_update {tagname normal_binary action_if_no_tag get_all_dirs dir args} {
     2   dorothyr #
     2   dorothyr # This updates the files in the current directory.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($tagname $normal_binary $action_if_no_tag $get_all_dirs $dir $args)"
     2   dorothyr 
     2   dorothyr   if { $normal_binary == "Normal" } {
     2   dorothyr       set mess "Using normal (text) mode.\n"
     2   dorothyr   } elseif { $normal_binary == "Binary" } {
     2   dorothyr       set mess "Using binary mode.\n"
     2   dorothyr   } else {
     2   dorothyr       set mess "Unknown mode:  $normal_binary\n"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if { $tagname != "BASE"  && $tagname != "HEAD" } {
     2   dorothyr       append mess "\nIf a file does not have tag $tagname"
     2   dorothyr       if { $action_if_no_tag == "Remove" } {
     2   dorothyr           append mess " it will be removed from your local directory.\n"
     2   dorothyr       } elseif { $action_if_no_tag == "Get_head" } {
     2   dorothyr           append mess " the head revision will be retrieved.\n"
     2   dorothyr       } elseif { $action_if_no_tag == "Skip" } {
     2   dorothyr           append mess " it will be skipped.\n"
     2   dorothyr       }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if { $tagname == "HEAD" } {
     2   dorothyr     append mess "\nYour local files will be updated to the"
     2   dorothyr     append mess " latest main trunk (head) revision."
     2   dorothyr     append mess " CVS will try to preserve any local, un-committed changes.\n"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   append mess "\nIf there is a directory in the repository"
     2   dorothyr   append mess " that is not in your local, working directory,"
     2   dorothyr   if { $get_all_dirs == "Yes" } {
     2   dorothyr     append mess " it will be checked out at this time.\n"
     2   dorothyr   } else {
     2   dorothyr     append mess " it will not be checked out.\n"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     append mess "\nYou are about to download from"
     2   dorothyr     append mess " the repository to your local"
     2   dorothyr     append mess " filespace ** ALL ** files which"
     2   dorothyr     append mess " have changed in it."
     2   dorothyr   } else {
     2   dorothyr     append mess "\nYou are about to download from"
     2   dorothyr     append mess " the repository to your local"
     2   dorothyr     append mess " filespace these files which"
     2   dorothyr     append mess " have changed:\n"
     2   dorothyr   
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append mess "\n\t$file"
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   append mess "\n\nAre you sure?"
     2   dorothyr   if {[cvsconfirm $mess .workdir] == "ok"} {
     2   dorothyr     # modified by jo to build the commandline incrementally
     2   dorothyr     set commandline "$cvs update -P"
     2   dorothyr     if { $normal_binary == "Binary" } {
     2   dorothyr       append commandline " -kb"
     2   dorothyr     }
     2   dorothyr     if { $get_all_dirs == "Yes" } {
     2   dorothyr       append commandline " -d $dir"
     2   dorothyr     }
     2   dorothyr     if { $tagname != "BASE" && $tagname != "HEAD" } {
     2   dorothyr       if { $action_if_no_tag == "Remove" } {
     2   dorothyr           append commandline " -r $tagname"
     2   dorothyr       } elseif { $action_if_no_tag == "Get_head" } {
     2   dorothyr           append commandline " -f -r $tagname"
     2   dorothyr       } elseif { $action_if_no_tag == "Skip" } {
     2   dorothyr           append commandline " -s -r $tagname"
     2   dorothyr       }
     2   dorothyr     }
     2   dorothyr     if { $tagname == "HEAD" } {
     2   dorothyr       append commandline " -A"
     2   dorothyr     }
     2   dorothyr     foreach file $filelist {
     2   dorothyr       append commandline " \"$file\""
     2   dorothyr     }
     2   dorothyr 
     2   dorothyr     #gen_log:log C $commandline
     5   dorothyr     set co_cmd [viewer::new "CVS Update"]
     5   dorothyr     $co_cmd\::do $commandline 0 status_colortags
     2   dorothyr     
     2   dorothyr     if {$cvscfg(auto_status)} {
     5   dorothyr       $co_cmd\::wait
     2   dorothyr       setup_dir
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_join {from since fromtag totag args} {
     2   dorothyr #
     2   dorothyr # This does a join (merge) of a chosen revision of localfile to the
     2   dorothyr # current revision.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global current_tagname
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($from $since $fromtag $totag $args)"
     2   dorothyr 
     2   dorothyr   set filelist $args
     2   dorothyr   set v [viewer::new "CVS Join"]
     2   dorothyr 
     2   dorothyr   set commandline "$cvs update -d -j$from $filelist"
     2   dorothyr   if {$since == ""} {
     2   dorothyr     set commandline "$cvs update -d -j$from $filelist"
     2   dorothyr   } else {
     2   dorothyr     set commandline "$cvs update -d -j$since -j$from $filelist"
     2   dorothyr   }
     2   dorothyr     
     2   dorothyr   $v\::do "$commandline" 0 status_colortags
     2   dorothyr   $v\::wait
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_tag)} {
     2   dorothyr     set comandline "$cvs tag -F -r $from $fromtag $filelist"
     2   dorothyr     $v\::do "$cvs tag -F -r $from $fromtag $filelist"
     2   dorothyr     toplevel .reminder
     2   dorothyr     message .reminder.m1 -aspect 600 -text \
     2   dorothyr       "When you are finished checking in your merges, \
     2   dorothyr       you should apply the tag"
     2   dorothyr     entry .reminder.ent -width 32 -relief raised -bd 1
     2   dorothyr     .reminder.ent insert end $totag 
     2   dorothyr     message .reminder.m2 -aspect 600 -text \
     2   dorothyr       "using the \"Tag the selected files\" button"
     2   dorothyr     frame .reminder.bottom -relief raised -bd 2
     2   dorothyr     button .reminder.bottom.close -text "Dismiss" \
     2   dorothyr       -command {destroy .reminder}
     2   dorothyr     pack .reminder.bottom -side bottom -fill x
     2   dorothyr     pack .reminder.bottom.close -side bottom -expand yes
     2   dorothyr     pack .reminder.m1 -side top
     2   dorothyr     pack .reminder.ent -side top -padx 2
     2   dorothyr     pack .reminder.m2 -side top
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_status {args} {
     2   dorothyr #
     2   dorothyr # This does a status report on the files in the current directory.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr 
     2   dorothyr   if {$args == "."} {
     2   dorothyr     set args ""
     2   dorothyr   }
     2   dorothyr   # if there are selected files, I want verbose output for those files
     2   dorothyr   # so I'm going to save the current setting here
     2   dorothyr   # - added by Jo
     2   dorothyr   set verbosity_setting ""
     2   dorothyr 
     2   dorothyr   busy_start .workdir.main
     2   dorothyr   set filelist [join $args]
     2   dorothyr   # if recurse option is true or there are no selected files, recurse
     2   dorothyr   set cmd_options ""
     2   dorothyr   if {! [info exists cvscfg(recurse)]} {
     2   dorothyr     set cmd_options "-l"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   # if there are selected files, use verbose output
     2   dorothyr   # but save the current setting so it can be reset
     2   dorothyr   # - added by Jo
     2   dorothyr   if {[llength $filelist] > 0 || \
     2   dorothyr       ([llength $filelist] == 1  && ! [file isdir $filelist])} {
     2   dorothyr     set verbosity_setting $cvscfg(rdetail)
     2   dorothyr     set cvscfg(rdetail) "verbose"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   # support verious levels of verboseness. Ideas derived from GIC
     2   dorothyr   set statcmd [exec::new "$cvs -Q status $cmd_options $filelist"]
     2   dorothyr   set raw_status [$statcmd\::output]
     2   dorothyr 
     2   dorothyr   if {$cvscfg(rdetail) == "verbose"} {
     2   dorothyr     view_output::new "CVS Status ($cvscfg(rdetail))" $raw_status
     2   dorothyr   } else {
     2   dorothyr     set cooked_status ""
     2   dorothyr     set stat_lines [split $raw_status "\n"]
     2   dorothyr     foreach statline $stat_lines {
     2   dorothyr       if {[string match "*Status:*" $statline]} {
     2   dorothyr         gen_log:log D "$statline"
     2   dorothyr         if {$cvscfg(rdetail) == "terse" &&\
     2   dorothyr             [string match "*Up-to-date*" $statline]} {
     2   dorothyr           continue
     2   dorothyr         } else {
     2   dorothyr           regsub {^File: } $statline {} statline
     2   dorothyr           regsub {Status:} $statline " " line
     2   dorothyr           append cooked_status $line
     2   dorothyr           append cooked_status "\n"
     2   dorothyr         }
     2   dorothyr       }
     2   dorothyr     }
     2   dorothyr     view_output::new "CVS Status ($cvscfg(rdetail))" $cooked_status
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   # reset the verbosity setting if necessary
     2   dorothyr   if { $verbosity_setting != "" } {
     2   dorothyr     set cvscfg(rdetail) $verbosity_setting
     2   dorothyr   }
     2   dorothyr   busy_done .workdir.main
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_check {directory} {
     2   dorothyr #
     2   dorothyr # This does a cvscheck on the files in the current directory.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($directory)"
     2   dorothyr 
     2   dorothyr   busy_start .workdir.main
     2   dorothyr 
     2   dorothyr   # The current directory doesn't have to be in CVS for cvs update to work.
     2   dorothyr 
     2   dorothyr   # Sometimes, cvs update doesn't work with ".", only with "" or an argument
     2   dorothyr   if {$directory == "."} {
     2   dorothyr     set directory ""
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set commandline "$cvs -n -q update $cvscfg(checkrecursive) $directory"
     2   dorothyr   #gen_log:log C "$commandline"
     2   dorothyr   set check_cmd [viewer::new "Directory Status Check"]
     2   dorothyr   $check_cmd\::do $commandline 0 status_colortags
     2   dorothyr 
     2   dorothyr   busy_done .workdir.main
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_checkout { dir cvsroot prune kflag revtag date target mtag1 mtag2 module } {
     2   dorothyr   #
     2   dorothyr   # This checks out a new module into the current directory.
     2   dorothyr   #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($dir $cvsroot $prune $kflag $revtag $date $target $mtag1 $mtag2 $module)"
     2   dorothyr 
     2   dorothyr   foreach {incvs inrcs module_dir} [cvsroot_check $dir] { break }
     2   dorothyr   if {$incvs} {
     2   dorothyr     set mess "This is already a CVS controlled directory.  Are you\
     2   dorothyr               sure that you want to check out another module in\
     2   dorothyr               to this directory?"
     2   dorothyr     if {[cvsconfirm $mess .modbrowse] != "ok"} {
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set mess "This will check out $module from CVS.\nAre you sure?"
     2   dorothyr   if {[cvsconfirm $mess .modbrowse] == "ok"} {
     2   dorothyr     if {$revtag != {}} {
     2   dorothyr       set revtag "-r \"$revtag\""
     2   dorothyr     }
     2   dorothyr     if {$date != {}} {
     2   dorothyr       set date "-D \"$date\""
     2   dorothyr     }
     2   dorothyr     if {$target != {}} {
     2   dorothyr       set target "-d \"$target\""
     2   dorothyr     }
     2   dorothyr     if {$mtag1 != {}} {
     2   dorothyr       set mtag1 "-j \"$mtag1\""
     2   dorothyr     }
     2   dorothyr     if {$mtag2 != {}} {
     2   dorothyr       set mtag2 "-j \"$mtag2\""
     2   dorothyr     }
     2   dorothyr     set v [::viewer::new "CVS Checkout"]
     2   dorothyr     set cwd [pwd]
     2   dorothyr     cd $dir
     2   dorothyr     $v\::do "$cvs -d \"$cvsroot\" checkout $prune\
     2   dorothyr              $revtag $date $target\
     2   dorothyr              $mtag1 $mtag2\
     2   dorothyr              $kflag \"$module\""
     2   dorothyr     cd $cwd
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr   return
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_filelog {filename parent} {
     2   dorothyr #
     2   dorothyr # This looks at the revision log of a file.  It's called from filebrowse.tcl, 
     2   dorothyr # so we can't do operations such as merges.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global cwd
     2   dorothyr   
     2   dorothyr   gen_log:log T "ENTER ($filename)"
     2   dorothyr   set pid [pid]
     2   dorothyr   set filetail [file tail $filename]
     2   dorothyr   
     2   dorothyr   set commandline "$cvs -d $cvscfg(cvsroot) checkout \"$filename\""
     2   dorothyr   gen_log:log C "$commandline"
     2   dorothyr   set ret [cvs_sandbox_runcmd "$commandline" cmd_output]
     2   dorothyr   if {$ret == $cwd} {
     2   dorothyr     cvsfail $cmd_output $parent
     2   dorothyr     cd $cwd
     2   dorothyr     gen_log:log T "LEAVE -- cvs checkout failed"
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set commandline "$cvs -d $cvscfg(cvsroot) log \"$filename\""
     2   dorothyr 
     2   dorothyr   # Log canvas viewer
     2   dorothyr   logcanvas::new [pwd] $filename "no file" $commandline
     2   dorothyr   cd $cwd
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_export { dir cvsroot kflag revtag date target module } {
     2   dorothyr #
     2   dorothyr # This exports a new module (see man cvs and read about export) into
     2   dorothyr # the current directory.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg 
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($dir $cvsroot $kflag $revtag $date $target $module)"
     2   dorothyr     
     2   dorothyr   foreach {incvs inrcs module_dir} [cvsroot_check $dir] { break }
     2   dorothyr   if {$incvs} { 
     2   dorothyr     set mess "This is already a CVS controlled directory.  Are you\
     2   dorothyr               sure that you want to export a module in to this directory?"
     2   dorothyr     if {[cvsconfirm $mess .modbrowse] != "ok"} {
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set mess "This will export $module from CVS.\nAre you sure?"
     2   dorothyr   if {[cvsconfirm $mess .modbrowse] == "ok"} {
     2   dorothyr     if {$revtag != {}} {
     2   dorothyr       set revtag "-r \"$revtag\""
     2   dorothyr     }
     2   dorothyr     if {$date != {}} {
     2   dorothyr       set date "-D \"$date\""
     2   dorothyr     }
     2   dorothyr     if {$target != {}} {
     2   dorothyr       set target "-d \"$target\""
     2   dorothyr     }
     2   dorothyr 
     2   dorothyr     set v [::viewer::new "CVS Export"]
     2   dorothyr     set cwd [pwd]
     2   dorothyr     cd $dir
     2   dorothyr     $v\::do "$cvs -d \"$cvsroot\" export\
     2   dorothyr              $revtag $date $target $kflag \"$module\""
     2   dorothyr     cd $cwd
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr   return
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_patch { cvsroot module difffmt revtagA dateA revtagB dateB outmode outfile } {
     2   dorothyr #
     2   dorothyr # This creates a patch file between two revisions of a module.  If the
     2   dorothyr # second revision is null, it creates a patch to the head revision.
     2   dorothyr # If both are null the top two revisions of the file are diffed.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr  
     2   dorothyr   gen_log:log T "ENTER ($cvsroot $module $difffmt $revtagA $dateA $revtagB $dateB $outmode $outfile)"
     2   dorothyr 
     2   dorothyr   foreach {rev1 rev2} {{} {}} { break }
     2   dorothyr   if {$revtagA != {}} {
     2   dorothyr     set rev1 "-r \"$revtagA\""
     2   dorothyr   } elseif {$dateA != {}} {
     2   dorothyr     set rev1 "-D \"$dateA\""
     2   dorothyr   }
     2   dorothyr   if {$revtagB != {}} {
     2   dorothyr     set rev2 "-r \"$revtagB\""
     2   dorothyr   } elseif {$dateA != {}} {
     2   dorothyr     set rev2 "-D \"$dateB\""
     2   dorothyr   }
     2   dorothyr   if {$rev1 == {} && $rev2 == {}} {
     2   dorothyr     set rev1 "-t"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set commandline "$cvs -d \"$cvsroot\" patch $difffmt $rev1 $rev2 \"$module\""
     2   dorothyr 
     2   dorothyr   if {$outmode == 0} {
     2   dorothyr     set v [viewer::new "CVS Patch"]
     2   dorothyr     $v\::do "$commandline" 0 patch_colortags
     2   dorothyr   } else {
     2   dorothyr     set e [exec::new "$commandline"]
     2   dorothyr     set patch [$e\::output]
     2   dorothyr     gen_log:log F "OPEN $outfile"
     2   dorothyr     if {[catch {set fo [open $outfile w]}]} {
     2   dorothyr       cvsfail "Cannot open $outfile for writing" .modbrowse
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr     puts $fo $patch
     2   dorothyr     close $fo
     2   dorothyr     gen_log:log F "CLOSE $outfile"
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr   return
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_version {} {
     2   dorothyr #
     2   dorothyr # This shows CVS banner.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER"
     2   dorothyr   set commandline "$cvs -v"
     2   dorothyr   #gen_log:log C "$commandline"
     2   dorothyr   set v [viewer::new "CVS version"]
     2   dorothyr   $v\::do "$commandline"
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_version_number {} {
     2   dorothyr #
     2   dorothyr # This finds the current CVS version number.
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER"
     2   dorothyr   set commandline "$cvs -v"
     2   dorothyr   #gen_log:log C "$commandline"
     2   dorothyr   set e [exec::new "$commandline" {} 0 parse_version]
     2   dorothyr   set number [$e\::output]
     2   dorothyr   regsub -all {\s*} $number {} number
     2   dorothyr   
     2   dorothyr   gen_log:log T "LEAVE ($number)"
     2   dorothyr   return $number
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_merge_conflict {args} {
     2   dorothyr   global cvscfg
     2   dorothyr   global cvs
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr 
     2   dorothyr   set filelist [join $args]
     2   dorothyr   if {$filelist == ""} {
     2   dorothyr     cvsfail "Please select some files to merge first!"
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   foreach file $filelist {
     2   dorothyr     # Make sure its really a conflict - tkdiff will bomb otherwise
     2   dorothyr     regsub -all {\$} $file {\$} filename
     2   dorothyr     set commandline "$cvs -n -q update \"$filename\""
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     catch {eval "exec $commandline"} status
     2   dorothyr     gen_log:log C "$status"
     2   dorothyr 
     2   dorothyr     gen_log:log F "OPEN $file"
     2   dorothyr     set f [open $file]
     2   dorothyr     set match 0
     2   dorothyr     while { [eof $f] == 0 } {
     2   dorothyr       gets $f line
     2   dorothyr       if { [string match "<<<<<<< *" $line] } {
     2   dorothyr         set match 1
     2   dorothyr         break
     2   dorothyr       }
     2   dorothyr     }
     2   dorothyr     gen_log:log F "CLOSE $file"
     2   dorothyr     close $f
     2   dorothyr    
     2   dorothyr     if { [string match "C *" $status] } {
     2   dorothyr       # If its marked "Needs Merge", we have to update before
     2   dorothyr       # we can resolve the conflict
     2   dorothyr       gen_log:log C "$commandline"
     2   dorothyr       set commandline "$cvs update \"$file\""
     2   dorothyr       gen_log:log C "$status"
     2   dorothyr       catch {eval "exec $commandline"} status
     2   dorothyr     } elseif { $match == 1 } { 
     2   dorothyr       # There are conflict markers already, dont update
     2   dorothyr       ;
     2   dorothyr     } else {
     2   dorothyr       cvsfail "This file does not appear to have a conflict." .workdir
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr     # Invoke tkdiff with the proper option for a conflict file
     2   dorothyr     # and have it write to the original file
     2   dorothyr     set commandline "$cvscfg(tkdiff) -conflict -o \"$filename\" \"$filename\""
     2   dorothyr     gen_log:log C "$commandline"
     2   dorothyr     catch {eval "exec $commandline"} view_this
     2   dorothyr   }
     2   dorothyr   
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_gettaglist {filename parent} {
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global cwd
     2   dorothyr 
     2   dorothyr   set keepers ""
     2   dorothyr   set pid [pid]
     2   dorothyr   gen_log:log T "ENTER ($filename)"
     2   dorothyr   set filetail [file tail $filename]
     2   dorothyr   
     2   dorothyr   set commandline "$cvs -d $cvscfg(cvsroot) checkout \"$filename\"" 
     2   dorothyr   # run a command, possibly creating the sandbox to play in
     2   dorothyr   set ret [cvs_sandbox_runcmd $commandline cmd_output]
     2   dorothyr   if {$cwd == $ret} {
     2   dorothyr     cvsfail $cmd_output $parent
     2   dorothyr     cd $cwd
     2   dorothyr     gen_log:log T "LEAVE ERROR ($cmd_output)"
     2   dorothyr     return $keepers
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set commandline "$cvs -d $cvscfg(cvsroot) log \"$filename\""
     2   dorothyr   gen_log:log C "$commandline"
     2   dorothyr   set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr   if {$ret} {
     2   dorothyr     cvsfail $view_this $parent
     2   dorothyr     cd $cwd
     2   dorothyr     gen_log:log T "LEAVE ERROR"
     2   dorothyr     return $keepers
     2   dorothyr   }
     2   dorothyr   set view_lines [split $view_this "\n"]
     2   dorothyr   foreach line $view_lines {
     2   dorothyr     if {[string index $line 0] == "\t" } {
     2   dorothyr       set line [string trimleft $line]
     2   dorothyr       gen_log:log D "$line"
     2   dorothyr       append keepers "$line\n"
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   if {$keepers == ""} {
     2   dorothyr     set keepers "No Tags"
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   cd $cwd
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr   return "$keepers"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_release {delflag directory} {
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($directory)"
     2   dorothyr   if {! [file isdirectory $directory]} {
     2   dorothyr     cvsfail "$directory is not a directory" .workdir
     2   dorothyr     return
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set commandline "$cvs -n -q update $directory"
     2   dorothyr   gen_log:log C "$commandline"
     2   dorothyr   set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr   if {$view_this != ""} {
     2   dorothyr     view_output::new "CVS Check" $view_this
     2   dorothyr     set mess "$directory is not up-to-date."
     2   dorothyr     append mess "\nRelease anyway?"
     2   dorothyr     if {[cvsconfirm $mess .workdir] != "ok"} {
     2   dorothyr       return
     2   dorothyr     }
     2   dorothyr   }
     2   dorothyr   set commandline "$cvs -Q release $delflag $directory"
     2   dorothyr   set ret [catch {eval "exec $commandline"} view_this]
     2   dorothyr   gen_log:log C "$commandline"
     2   dorothyr   if {$ret != 0} {
     2   dorothyr     view_output::new "CVS Release" $view_this
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_rtag { cvsroot mcode branch force oldtag newtag } {
     2   dorothyr #
     2   dorothyr # This tags a module in the repository.
     2   dorothyr # Called by the tag commands in the Module Browser
     2   dorothyr #
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   
     2   dorothyr   gen_log:log T "ENTER ($cvsroot $mcode $branch $force $oldtag $newtag)"
     2   dorothyr   if {$newtag == ""} {
     2   dorothyr     cvsfail "You must enter a tag name!" .modbrowse
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   set command "$cvs -d \"$cvsroot\" rtag"
     2   dorothyr   if {$branch == "yes"} {
     2   dorothyr     append command " -b"
     2   dorothyr   } 
     2   dorothyr   if {$force == "yes"} {
     2   dorothyr     append command " -F" 
     2   dorothyr   }   
     2   dorothyr   if {$oldtag != ""} {
     2   dorothyr     append command " -r \"$oldtag\""
     2   dorothyr   }
     2   dorothyr   append command " \"$newtag\" \"$mcode\""
     2   dorothyr 
     2   dorothyr   set v [::viewer::new "CVS Rtag"]
     2   dorothyr   $v\::do "$command"
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_ascii { args } {
     2   dorothyr # This converts a binary file to ASCII
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr   global cvsglb
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr 
     2   dorothyr   gen_log:log D "Changing sticky flag"
     2   dorothyr   gen_log:log D "$cvs admin -kkv $filelist"
     2   dorothyr   set cmd [exec::new "$cvs admin -kkv $filelist"]
     2   dorothyr   # gen_log:log D "Updating file list"
     2   dorothyr   # set cmd [exec::new "$cvs update $filelist"]
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     $cmd\::wait
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     2   dorothyr 
     2   dorothyr proc cvs_binary { args } {
     2   dorothyr # This converts an ASCII file to binary
     2   dorothyr   global cvs
     2   dorothyr   global cvscfg
     2   dorothyr   global incvs
     2   dorothyr   global cvsglb
     2   dorothyr 
     2   dorothyr   gen_log:log T "ENTER ($args)"
     2   dorothyr   if {! $incvs} {
     2   dorothyr     cvs_notincvs
     2   dorothyr     return 1
     2   dorothyr   }
     2   dorothyr   set filelist [join $args]
     2   dorothyr 
     2   dorothyr   gen_log:log D "Changing sticky flag"
     2   dorothyr   gen_log:log D "$cvs admin -kb $filelist"
     2   dorothyr   set cmd [exec::new "$cvs admin -kb $filelist"]
     2   dorothyr   # gen_log:log D "Updating file list"
     2   dorothyr   # set cmd [exec::new "$cvs update $filelist"]
     2   dorothyr   if {$cvscfg(auto_status)} {
     2   dorothyr     $cmd\::wait
     2   dorothyr     setup_dir
     2   dorothyr   }
     2   dorothyr 
     2   dorothyr   gen_log:log T "LEAVE"
     2   dorothyr }
     7   dorothyr 
     8   dorothyr proc read_cvs_dir {dirname} {
     8   dorothyr #
     8   dorothyr # Reads a CVS "bookkeeping" directory
     8   dorothyr #
     8   dorothyr   global module_dir
     8   dorothyr   global cvscfg
     8   dorothyr   global current_tagname
     8   dorothyr 
     8   dorothyr   gen_log:log T "ENTER ($dirname)"
     8   dorothyr   if {[file isdirectory $dirname]} {
     8   dorothyr     if {[file isfile [file join $dirname Repository]]} {
     8   dorothyr       gen_log:log F "OPEN CVS/Repository"
     8   dorothyr       set f [open [file join $dirname Repository] r]
     8   dorothyr       gets $f module_dir
     8   dorothyr       close $f
     8   dorothyr       gen_log:log D "  MODULE $module_dir"
     8   dorothyr       if {[file isfile [file join $dirname Root]]} {
     8   dorothyr         gen_log:log F "OPEN CVS/Root"
     8   dorothyr         set f [open [file join $dirname Root] r]
     8   dorothyr         gets $f cvscfg(cvsroot)
     8   dorothyr         close $f
     8   dorothyr         # On a PC, the cvsroot can be like C:\DosRepository.
     8   dorothyr         # This makes that workable.
     8   dorothyr         regsub -all {\\} $cvscfg(cvsroot) {\\\\} cvscfg(cvsroot)
     8   dorothyr         gen_log:log D " cvsroot: $cvscfg(cvsroot)"
     8   dorothyr       }
     8   dorothyr       if {[file isfile [file join $dirname Tag]]} {
     8   dorothyr         gen_log:log F "OPEN CVS/Tag"
     8   dorothyr         set f [open [file join $dirname Tag] r]
     8   dorothyr         gets $f current_tagname
     8   dorothyr         close $f
     8   dorothyr         # T = branch tag, N = non-branch, D = sticky date
     8   dorothyr         set current_tagname [string range $current_tagname 1 end]
     8   dorothyr         gen_log:log D "  BRANCH TAG $current_tagname"
     8   dorothyr       }
     8   dorothyr     } else {
     8   dorothyr       cvsfail "Repository file not found in $dirname" .workdir
     8   dorothyr     }
     8   dorothyr   } else {
     8   dorothyr     cvsfail "$dirname is not a directory" .workdir
     8   dorothyr   }
     8   dorothyr   gen_log:log T "LEAVE"
     8   dorothyr }
     8   dorothyr 
     7   dorothyr proc parse_cvsmodules {modules_file} {
     7   dorothyr   global cvs
     7   dorothyr   global modval
     7   dorothyr   global modtitle
     7   dorothyr   global cvsglb
     7   dorothyr   global cvscfg
     7   dorothyr 
     7   dorothyr   gen_log:log T "ENTER"
     7   dorothyr 
     7   dorothyr   # Clear the arrays
     7   dorothyr   catch {unset modval}
     7   dorothyr   catch {unset modtitle}
     7   dorothyr 
     7   dorothyr   # Unescape newlines, compress repeated whitespace, and remove blank lines
     7   dorothyr   regsub -all {(\\\n|[ \t])+} $modules_file " " modules_file
     7   dorothyr   regsub -all {\n\s*\n+} $modules_file "\n" modules_file
     7   dorothyr 
     7   dorothyr   foreach line [split $modules_file "\n"] {
     7   dorothyr     if {[string index $line 0] == {#}} {
     7   dorothyr #     gen_log:log D "Comment: $line"
     7   dorothyr       if {[string index $line 1] == {D} || [string index $line 1] == {M}} {
     7   dorothyr         set text [split $line]
     7   dorothyr         set dname [lindex $text 1]
     7   dorothyr         set modtitle($dname) [lrange $text 2 end]
     7   dorothyr #       gen_log:log D "Directory: {$dname} {$modtitle($dname)}"
     7   dorothyr       }
     7   dorothyr     } else {
     7   dorothyr #     gen_log:log D "Data: $line"
     7   dorothyr       set text [split $line]
     7   dorothyr       set modname [lindex $text 0]
     7   dorothyr       set modstring [string trim [join [lrange $text 1 end]]]
     7   dorothyr       # A "#D ..." or "#M ..." entry _always_ overrides this default
     7   dorothyr       if {! [info exists modtitle($modname)]} {
     7   dorothyr         set modtitle($modname) $modstring
     7   dorothyr       }
     7   dorothyr       # Remove flags except for -a.  Luckily alias modules can't have
     7   dorothyr       # any other options.
     7   dorothyr #     gen_log:log D "{$modname} {$modstring}"
     7   dorothyr       regsub -- {^((-l\s*)|(-[ioestud]\s+((\\\s)|\S)+\s*))+} \
     7   dorothyr         $modstring {} modstring
     7   dorothyr      gen_log:log D "{$modname} {$modstring}"
     7   dorothyr       set modval($modname) $modstring
     7   dorothyr     }
     7   dorothyr   }
     7   dorothyr 
     7   dorothyr   gen_log:log T "LEAVE"
     7   dorothyr }
     7   dorothyr 
